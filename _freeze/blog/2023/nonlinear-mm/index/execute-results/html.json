{
  "hash": "9b4405c1d280f229a08a09b787c4c134",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Nonlinear mixed-effect models for individual differences in growth\"\ndraft: false\nimage: \"blog/2023/nonlinear-mm/figs/fig.title.png\"\ndate: last-modified\ncategories:\n  - Gompertz growth\n  - R\n  - STAN\n  - brms\n  - Bayesian\nformat:\n  html: \n    code-fold: false\n    fig-cap-location: bottom\n    shift-heading-level-by: 1\n    embed-resources: true\ntoc: true\ntoc-depth: 5\ntoc-location: left\nexecute:\n  echo: true\n  warning: false\n  message: false\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\n(*Update 18/03/2024: Fixing minor formatting issues*)\n\n\nLoad libraries\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tidyverse); library(patchwork); library(tidybayes)\nlibrary(brms); library(marginaleffects); library(viridis)\nlibrary(easystats); library(kableExtra)\n```\n:::\n\n\nSet theme\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_bw(16))\n```\n:::\n\n\nWe're first going to load all model objects stored in the `stan` folder to avoid rerunning all those pesky Bayesian computations.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Make a vector of file paths\nfile_paths <- list.files(path = \"stan/\", \n                         pattern = \"\\\\.rds\", full.names = TRUE)\n\n# Make a vector of file names\nfile_names <-  gsub(pattern = \"\\\\.rds$\", replacement = \"\", \n                    x = basename(file_paths))\n\n# Read all models into a list\nmods_list <- lapply(file_paths, readRDS)\n\n# Assign file names to list elements\nnames(mods_list) <- file_names      \n```\n:::\n\n\n\n## Rationale\nI've been working a lot with nonlinear models lately. In many cases across ecology and evolution, trends do not go on forever. Having modeling approaches that can account for boundaries and plateaus is therefore very important in specific situations. In my case I'm generally interested in how contamination exposure affects growth, reproduction and behavior of invertebrates and its consequences on individual fitness. In this post I'm exploring how to use nonlinear mixed effect models of growth to recover individual trajectories using simulated data. I'm mostly using the `{brms}` package for now as it provides a very user-friendly syntax for fitting these models. The level of complexity I'm dealing with is veering dangerously toward a full `STAN` implementation, especially when I'll have to deal with jointly modeling fitness, but that's a problem for future me! \n\n## Inspiration\nA lot of the code in this document has been taken and adapted from Solomon Kurtz's work and his translation of Richard McElreath's [Statistical Rethinking]() book into `{brms}` syntax. Specifically, the simulation of individual differences is directly inspired from working through [Chapter 14 section 1.3](https://bookdown.org/content/4857/adventures-in-covariance.html#the-varying-slopes-model.). Many thanks to them for putting out all this material in an open format!\n\n## Model description\nI'm using the model described in [Goussen et al. (2013)](https://doi.org/10.1007/s10646-013-1078-5) showing adaptation of *C. elegans* to Uranium.\nThe model assumes nematodes body-length grows according to the following Gompertz function:\n\n$$\nL = L_{inf}\\times e^{ln \\left( \\frac{L_0}{Linf} \\right) \\times e^{-\\alpha t} }$$\n\nwhere $L_{inf}$ is the asymptotic body-length, $L_0$ is the body-length at hatching and $\\alpha$ the growth rate.\n\nPlugging in the values from the paper gives a sigmoid growth curve:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Store parameters for non-exposed populations\nn_id = 10 # 10 individuals\nobs = seq(0, 126, by = 24) # One observation every day\nLinf = 1370\nL0 = 182\nalpha = 0.028\nt = seq(0,126, by = 1) # measure every h for 126 h \nsigma = 100 # random noise\n\nGomp.fun = function(t, Linf, L0, alpha){\n  Lhat = Linf * exp(log(L0/Linf)*exp(-alpha*t)) # predicted growth\n  return(Lhat)\n}\n\n# Apply equation\nset.seed(42)\ndf = crossing(obs, 1:n_id) %>% \n  mutate(Lhat = Gomp.fun(obs, Linf = Linf, L0 = L0, alpha = alpha)) %>% \n  mutate(L = rnorm(n(), Lhat, sigma))\ndf %>% \n  ggplot(aes(y = L, x = obs)) +\n  geom_point(alpha = .2, size = 2.5) +\n  geom_function(fun = Gomp.fun, \n                     args = list(Linf = Linf, L0 = L0, alpha = alpha),\n                     color = \"red\", size = 1) +\n  ylim(0, 1600) +\n  labs(x = \"Hours since hatching\", y = \"Body-length (mum)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n## Simulating individual differences\n\nWe can use the `brms` package to make simulations according to some prior distributions for our parameters. We first need to store the values of the growth parameters for each individual\n\n### Data simulations\nI'm using the same approach as above but now allow individual to have some deviation from the population mean for all parameters: $\\mu_i \\sim N(mu + \\text{offset}, \\text{ } \\sigma)$ where $\\mu$ and $\\mu_i$ are the individual and population mean for a given parameter and the offset is calculated as: $\\text{offset} \\sim N(0, \\text{ } \\sigma_i)$ where $\\sigma_i$ is the among-individual standard deviation for a given parameters. In our simulation, we assume a coefficient of variation 10 % for all parameters such that $\\sigma_i = 0.10 \\times \\mu$\n\n::: {.callout-note}\n## Note \nThere are different ways to interpret the $L_{inf}$ parameter. In Goussen et al' paper, this was assumed to be the maximum body-size for the population. Meaning that with enough time, all individuals will converge toward this value. Most individuals of course will die before that! Here, I am assuming that all individuals have their own maximum size they can reach. This means that two individuals with the same growth rate measured for the same amount of time may still differ in their maximum length.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_id = 30 # 30 individuals\ntimes = seq(0, 126, by = 24) # One observation every day\nsd = 10 # random noise\nL0_mu = 182 # initial length (micrometers)\nLinf_mu = 1370 # maximal length (micrometers)\nalpha_mu = 0.028 # Growth rate (hour^-1)\n\nrho = 0 # Suppose all parameters are independent\n\nmu     = c(L0_mu, Linf_mu, alpha_mu)\nsigmas = c(L0_mu*.1, Linf_mu*.1, alpha_mu*.1) # 10 % CV around the mean\nrho_mat = matrix(c(1, rho, rho,\n                    rho, 1, rho,\n                    rho, rho, 1), \n                    nrow = 3)\n\nsigma = diag(sigmas) %*% rho_mat %*% diag(sigmas)\n\nset.seed(42)\nID = MASS::mvrnorm(n_id, mu, sigma) %>% \n  data.frame() %>% \n  set_names(\"L0_i\", \"Linf_i\", \"alpha_i\") %>% \n  mutate(ID = 1:n_id)\n\n# Simulate individual growth\ndf = ID %>%\n  tidyr::expand(nesting(ID, L0_i, Linf_i, alpha_i), \n                t = times) %>%\n  mutate(Lhat = Linf_i * exp(log(L0_i/Linf_i)*exp(-alpha_i*t))) %>%\n  mutate(L = rnorm(n(), Lhat, sd))\n\nfig.title = df %>% \n  ggplot(aes(y = L, x = t, group = ID)) +\n  geom_point(alpha = .2, size = 2.5) +\n  geom_line(alpha = .2, size = .5) +\n  geom_function(fun = Gomp.fun, \n                     args = list(Linf = Linf, L0 = L0, alpha = alpha),\n                     color = \"red\", size = 1) +\n  ylim(0, 1600) +\n  labs(x = \"Hours since hatching\", \n       y = expression(paste(\"Body-length (\", mu, \"m)\")))\nfig.title\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### Defining the model in `brms`\n\nIn `brms`, we can use the standard `R` formula syntax to specify the Gompertz model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf = bf(L ~ \n           Linf * exp(log(L0 / Linf) * exp(-alpha * t)), # Gompertz population curve\n         L0 + Linf + alpha ~ 1 + (1|ID), # parameters with random effects\n         nl = T)\npriors = get_prior(bf, df)\npriors %>% kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|prior                  |class |coef      |group |resp |dpar |nlpar |lb |ub |source  |\n|:----------------------|:-----|:---------|:-----|:----|:----|:-----|:--|:--|:-------|\n|student_t(3, 0, 521.9) |sigma |          |      |     |     |      |0  |   |default |\n|                       |b     |          |      |     |     |alpha |   |   |default |\n|                       |b     |Intercept |      |     |     |alpha |   |   |default |\n|student_t(3, 0, 521.9) |sd    |          |      |     |     |alpha |0  |   |default |\n|                       |sd    |          |ID    |     |     |alpha |   |   |default |\n|                       |sd    |Intercept |ID    |     |     |alpha |   |   |default |\n|                       |b     |          |      |     |     |L0    |   |   |default |\n|                       |b     |Intercept |      |     |     |L0    |   |   |default |\n|student_t(3, 0, 521.9) |sd    |          |      |     |     |L0    |0  |   |default |\n|                       |sd    |          |ID    |     |     |L0    |   |   |default |\n|                       |sd    |Intercept |ID    |     |     |L0    |   |   |default |\n|                       |b     |          |      |     |     |Linf  |   |   |default |\n|                       |b     |Intercept |      |     |     |Linf  |   |   |default |\n|student_t(3, 0, 521.9) |sd    |          |      |     |     |Linf  |0  |   |default |\n|                       |sd    |          |ID    |     |     |Linf  |   |   |default |\n|                       |sd    |Intercept |ID    |     |     |Linf  |   |   |default |\n\n\n:::\n:::\n\n\nThese are default priors and may not be well-suited for our problem. For some reason, `brms` won't let us sample from these default priors, but we can easily illustrate the point by setting unrealistically uninformative priors (i.e. normal(0, 100) here) on these parameters. I'm using the lower bound argument `lb = 0` to keep the growth positive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors = priors = \n  # Intercept priors\n  prior(normal(0, 100), nlpar = L0, class = b, lb = 0) +\n  prior(normal(0, 100), nlpar = Linf, class = b, lb = 0) +\n  prior(normal(0, 100), nlpar = alpha, class = b, lb = 0)\n```\n:::\n\n\nNext, we fit the model and simply specify `sample_prior = \"only\"` in the `brm()` function to only get the growth trends implied by the priors\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plotting\nplot(conditional_effects(mods_list$gomp.prior.default, \n                         ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nNot very good right?! Let's retry now with more reasonable priors\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors = \n  # Intercept priors\n  prior(normal(200, 40), nlpar = L0, class = b, lb = 0) +\n  prior(normal(1500, 300), nlpar = Linf, class = b, lb = 0) +\n  prior(normal(.03,.006), nlpar = alpha, class = b, lb = 0) + \n  # Random effects priors (informative priors with 20 % CV)\n  prior(exponential(.025), nlpar = L0, class = sd, group = ID) +\n  prior(exponential(.003), nlpar = Linf, class = sd, group = ID) +\n  prior(exponential(170), nlpar = alpha, class = sd, group = ID) +\n  # Residual prior\n  prior(exponential(1), class = sigma) \n\n# Plot priors\np1 = priors %>% \n  parse_dist() %>% \n  filter(class == \"b\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Intercepts\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n\np2 = priors %>% \n  parse_dist() %>% \n  filter(class == \"sd\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Among-individual variance\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n\np3 = priors %>% \n  parse_dist() %>% \n  filter(class == \"sigma\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Residual variance\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n \n(p1 + p2 + p3) + plot_layout(ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### Prior predictive checks\n\nWe can now check if the model shows a more appropriate gortwh curve while sampling only from these new priors. \n\n\n::: {.cell}\n\n:::\n\n\nInspecting the model and plotting predicted growth\n\n::: {.cell}\n\n```{.r .cell-code}\nmods_list$gomp.prior\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: L ~ Linf * exp(log(L0/Linf) * exp(-alpha * t)) \n         L0 ~ 1 + (1 | ID)\n         Linf ~ 1 + (1 | ID)\n         alpha ~ 1 + (1 | ID)\n   Data: df (Number of observations: 180) \n  Draws: 4 chains, each with iter = 1000; warmup = 500; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~ID (Number of levels: 30) \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(L0_Intercept)       40.67     42.23     1.14   156.94 1.00     2507     1141\nsd(Linf_Intercept)    332.87    334.35     8.69  1223.07 1.00     2706      955\nsd(alpha_Intercept)     0.01      0.01     0.00     0.02 1.00     2892     1169\n\nRegression Coefficients:\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nL0_Intercept      198.73     41.39   120.14   281.26 1.00     3330     1271\nLinf_Intercept   1492.43    311.92   885.14  2091.52 1.00     3261     1357\nalpha_Intercept     0.03      0.01     0.02     0.04 1.00     3684     1428\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.03      1.00     0.04     3.46 1.00     2297     1327\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(conditional_effects(mods_list$gomp.prior, \n                         ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n```{.r .cell-code}\nre = crossing(t = seq(min(df$t), \n                       max(df$t),\n                       length.out=100),\n               ID = unique(df$ID)) %>% \n  add_epred_draws(mods_list$gomp.prior, re_formula = NULL, \n                  scale = \"response\", ndraws = 20)\n\nre %>% \n  ggplot(aes(y = .epred, x = t)) +\n  geom_line(aes(y = .epred, x = t, group = .draw), size = .5, alpha = .5) +\n  geom_point(data = df, aes(y=L, x=t, color = ID)) +\n  facet_wrap(~ID, nrow = 6, ncol = 5) + \n  scale_color_viridis() +\n  ylab(\"Mass (mg)\") + \n  xlab(\"Time\") +\n  theme_bw(12) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n:::\n\n\n### Fit model to simulated data\n\nNext, we can fit the model to the simulated dataset\n\n\n::: {.cell}\n\n:::\n\nInspecting the model and plotting predicted growth\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(mods_list$gomp, effects = \"all\") %>% \n  kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|Parameter              |Effects |Component   |  Median|   CI| CI_low| CI_high| pd|  Rhat|  ESS|Group |\n|:----------------------|:-------|:-----------|-------:|----:|------:|-------:|--:|-----:|----:|:-----|\n|b_L0_Intercept         |fixed   |conditional |  179.45| 0.95| 170.68|  453.99|  1| 16.77| 2.01|      |\n|b_Linf_Intercept       |fixed   |conditional | 1362.79| 0.95|   0.08| 1434.54|  1| 23.18| 2.00|      |\n|b_alpha_Intercept      |fixed   |conditional |    0.03| 0.95|   0.00|    0.03|  1| 32.25| 2.00|      |\n|sd_ID__L0_Intercept    |random  |conditional |   18.31| 0.95|   1.50|   27.59|  1|  1.23| 6.34|ID    |\n|sd_ID__Linf_Intercept  |random  |conditional |  156.11| 0.95|   0.01|  215.75|  1|  3.98| 2.12|ID    |\n|sd_ID__alpha_Intercept |random  |conditional |    0.00| 0.95|   0.00|    0.00|  1|  1.51| 3.46|ID    |\n|sigma                  |fixed   |sigma       |    9.75| 0.95|   8.36|  139.79|  1| 20.58| 2.01|      |\n\n\n:::\n\n```{.r .cell-code}\npp_check(mods_list$gomp, ndraws = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(conditional_effects(mods_list$gomp, ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n\n```{.r .cell-code}\nre = crossing(t = seq(min(df$t), \n                       max(df$t),\n                       length.out=100),\n               ID = unique(df$ID)) %>% \n  add_epred_draws(mods_list$gomp, re_formula = NULL, \n                  scale = \"response\", ndraws = 20)\n\nre %>% \n  ggplot(aes(y = .epred, x = t)) +\n  geom_line(aes(y = .epred, x = t, group = .draw), size = .5, alpha = .5) +\n  geom_point(data = df, aes(y=L, x=t, color = ID)) +\n  facet_wrap(~ID, nrow = 6, ncol = 5) + \n  scale_color_viridis() +\n  ylab(\"Mass (mg)\") + \n  xlab(\"Time\") +\n  theme_bw(12) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-3.png){width=672}\n:::\n:::\n\nThe model functions correctly but there are a lot of divergent transitions and some poor convergence diagnostics. Let's try reparametrizing to improve the sampling.\n\n### Model reparametrization\n\nWe can express all body-length parameters as a function of the maximum length to help the model converge. Divinding each side of the Gompertz equation gives\n\n$$\\begin{aligned}\nl &= L/L_{inf}\\\\\nl_0 &=L_0/L_{inf}\\\\\nl &= e^{ln \\left( l_0 \\right) \\times e^{-\\alpha t} }\n\\end{aligned}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_function(fun = Gomp.fun, \n                     args = list(Linf = 1, L0 = L0/Linf, alpha = alpha),\n                     color = \"red\", size = 1) +\n  xlim(0, 126) + ylim(0, 1) +\n  labs(x = \"Hours since hatching\", y = \"Scaled body-length\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n#### Prior predictive checks\n\nWe need to reformulate model formula and priors in order to get sensible outputs\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$l = with(df, L/Linf)\n\nbf = bf(l ~ \n           exp(log(l0) * exp(-alpha * t)), # Gompertz population curve\n         l0 + alpha ~ 1 + (1|ID), # parameters with random effects\n         nl = T)\n```\n:::\n\n\nDefining and plotting priors\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors = \n  # Intercept priors\n  prior(normal(.15, .03), nlpar = l0, class = b, lb = 0) +\n  prior(normal(.03,.006), nlpar = alpha, class = b, lb = 0) + \n  # Random effects priors (informative priors with 20 % CV)\n  prior(exponential(34), nlpar = l0, class = sd, group = ID) +\n  prior(exponential(170), nlpar = alpha, class = sd, group = ID) +\n  # Residual prior\n  prior(exponential(1), class = sigma) \n\n# Plot priors\np1 = priors %>% \n  parse_dist() %>% \n  filter(class == \"b\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Intercepts\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n\np2 = priors %>% \n  parse_dist() %>% \n  filter(class == \"sd\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Among-individual variance\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n\np3 = priors %>% \n  parse_dist() %>% \n  filter(class == \"sigma\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Residual variance\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n \n(p1 + p2 + p3) + plot_layout(ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nAnd now running the model on priors only\n\n\n::: {.cell}\n\n:::\n\n\nModel inspection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(mods_list$gomp.sc.prior, effects = \"all\") %>%\n  kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|Parameter              |Effects |Component   | Median|   CI| CI_low| CI_high| pd| Rhat|     ESS|Group |\n|:----------------------|:-------|:-----------|------:|----:|------:|-------:|--:|----:|-------:|:-----|\n|b_l0_Intercept         |fixed   |conditional |   0.15| 0.95|   0.09|    0.20|  1|    1| 2769.57|      |\n|b_alpha_Intercept      |fixed   |conditional |   0.03| 0.95|   0.02|    0.04|  1|    1| 2270.10|      |\n|sd_ID__l0_Intercept    |random  |conditional |   0.02| 0.95|   0.00|    0.12|  1|    1| 2925.44|ID    |\n|sd_ID__alpha_Intercept |random  |conditional |   0.00| 0.95|   0.00|    0.02|  1|    1| 2850.84|ID    |\n|sigma                  |fixed   |sigma       |   0.69| 0.95|   0.02|    3.91|  1|    1| 2914.29|      |\n\n\n:::\n\n```{.r .cell-code}\nplot(conditional_effects(mods_list$gomp.sc.prior, \n                         ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\nre = crossing(t = seq(min(df$t), \n                       max(df$t),\n                       length.out=100),\n               ID = unique(df$ID)) %>% \n  add_epred_draws(mods_list$gomp.sc.prior, re_formula = NULL, \n                  scale = \"response\", ndraws = 20)\n\nre %>% \n  ggplot(aes(y = .epred, x = t)) +\n  geom_line(aes(y = .epred, x = t, group = .draw), size = .5, alpha = .5) +\n  geom_point(data = df, aes(y=l, x=t, color = ID)) +\n  facet_wrap(~ID, nrow = 6, ncol = 5) + \n  scale_color_viridis() +\n  ylab(\"Mass (mg)\") + \n  xlab(\"Time\") +\n  theme_bw(12) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n\n#### Fitting model to data\n\nAs above we rerun the scaled model on the scaled data\n\n\n\n::: {.cell}\n\n:::\n\n\nModel inspection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(mods_list$gomp.sc, effects = \"all\") %>%\n  kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|Parameter              |Effects |Component   | Median|   CI| CI_low| CI_high| pd| Rhat|     ESS|Group |\n|:----------------------|:-------|:-----------|------:|----:|------:|-------:|--:|----:|-------:|:-----|\n|b_l0_Intercept         |fixed   |conditional |   0.13| 0.95|   0.12|    0.14|  1| 1.00| 4283.00|      |\n|b_alpha_Intercept      |fixed   |conditional |   0.03| 0.95|   0.03|    0.03|  1| 1.00|  657.83|      |\n|sd_ID__l0_Intercept    |random  |conditional |   0.01| 0.95|   0.00|    0.02|  1| 1.01|  989.17|ID    |\n|sd_ID__alpha_Intercept |random  |conditional |   0.01| 0.95|   0.00|    0.01|  1| 1.00|  733.22|ID    |\n|sigma                  |fixed   |sigma       |   0.04| 0.95|   0.03|    0.04|  1| 1.00| 3774.40|      |\n\n\n:::\n\n```{.r .cell-code}\nplot(conditional_effects(mods_list$gomp.sc, \n                         ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n\n```{.r .cell-code}\npp_check(mods_list$gomp.sc, ndraws = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-2.png){width=672}\n:::\n\n```{.r .cell-code}\nre = crossing(t = seq(min(df$t), \n                       max(df$t),\n                       length.out=100),\n               ID = unique(df$ID)) %>% \n  add_epred_draws(mods_list$gomp.sc, re_formula = NULL, \n                  scale = \"response\", ndraws = 20)\n\nre %>% \n  ggplot(aes(y = .epred, x = t)) +\n  geom_line(aes(y = .epred, x = t, group = .draw), size = .5, alpha = .5) +\n  geom_point(data = df, aes(y=l, x=t, color = ID)) +\n  facet_wrap(~ID, nrow = 6, ncol = 5) + \n  scale_color_viridis() +\n  ylab(\"Mass (mg)\") + \n  xlab(\"Time\") +\n  theme_bw(12) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-3.png){width=672}\n:::\n:::\n\n\nMuch better!\n\n## Assuming a trade-off between maximum size and growth-rate\nSo far, we have assumed that all our parameters are independent. However, trade-offs between various life-history traits are also likely to occur. One such trade-off is the compromise between fast growth and reproductive rate, such that individuals that mature sooner reach a smaller asymptotic length. This is the case in  collembolas exposed to Cadmium for example.\nWe can easily modify our simulation function to incorporate a similar trade-off in our data.\n\n\n### Data simulations and modeling\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_id = 30 # 30 individuals\ntimes = seq(0, 126, by = 24) # One observation every day\nsd = 10 # random noise\nL0_mu = 182 # initial length (micrometers)\nLinf_mu = 1370 # maximal length (micrometers)\nalpha_mu = 0.028 # Growth rate (hour^-1)\n\nrho = -.7 # Assume strong negative correlation between Linf and alpha\n\nmu     = c(L0_mu, Linf_mu, alpha_mu)\nsigmas = c(L0_mu*.1, Linf_mu*.1, alpha_mu*.1) # 10 % CV around the mean\nrho_mat = matrix(c(1, 0, 0,\n                    0, 1, rho,\n                    0, rho, 1), \n                    nrow = 3)\n\nsigma = diag(sigmas) %*% rho_mat %*% diag(sigmas)\n\nset.seed(42)\nID = MASS::mvrnorm(n_id, mu, sigma) %>% \n  data.frame() %>% \n  set_names(\"L0_i\", \"Linf_i\", \"alpha_i\") %>% \n  mutate(ID = 1:n_id)\n\n# Plot\nID %>% \n  select(-ID) %>% \n  GGally::ggpairs() +\n  theme_bw() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\nAnd now we simulate growth over 126 hours as before\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate individual growth\ndf = ID %>%\n  tidyr::expand(nesting(ID, L0_i, Linf_i, alpha_i), \n                t = times) %>%\n  mutate(Lhat = Linf_i * exp(log(L0_i/Linf_i)*exp(-alpha_i*t))) %>%\n  mutate(L = rnorm(n(), Lhat, sd))\n\ndf %>% \n  ggplot(aes(y = L, x = t, group = ID)) +\n  geom_point(alpha = .2, size = 2.5) +\n  geom_line(alpha = .2, size = .5) +\n  geom_function(fun = Gomp.fun, \n                     args = list(Linf = Linf_mu, L0 = L0_mu, alpha = alpha_mu),\n                     color = \"red\", size = 1) +\n  ylim(0, 1600) +\n  labs(x = \"Hours since hatching\", y = \"Body-length (mum)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nSwitching directly to fitting the model to the data, we make some small adjustments to the formula\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$l = with(df, L/Linf_mu)\n\nbf = bf(l ~ \n           linf*exp(log(l0/linf) * exp(-alpha * t)), # Gompertz population curve\n         l0 + linf + alpha ~ 1 + (1|c|ID), # parameters with random effects\n         nl = T)\n```\n:::\n\n\nWe introduce a scaled version of $L_{inf}$ into the formula and allow random effects to be correlated with the `(1|c|ID)` chunk. Next we need to specify a strong prior for on $l_{inf}$ to constrain it around 1. We also specify a prior on the correlation parameter using an LKJ prior of parameter $\\eta>1$\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors = \n  # Intercept priors\n  prior(normal(.15, .03), nlpar = l0, class = b, lb = 0) +\n  prior(normal(1, .03), nlpar = linf, class = b, lb = 0) +\n  prior(normal(.03,.006), nlpar = alpha, class = b, lb = 0) + \n  # Random effects priors (informative priors with 20 % CV)\n  prior(exponential(34), nlpar = l0, class = sd, group = ID) +\n  prior(exponential(5), nlpar = linf, class = sd, group = ID) +\n  prior(exponential(170), nlpar = alpha, class = sd, group = ID) +\n  # Residual prior\n  prior(exponential(1), class = sigma) +\n  # Correlation prior\n  prior(lkj(2), class = cor)\n\n\n# Plot priors for linf\npriors %>% \n  parse_dist() %>% \n  filter(nlpar == \"linf\") %>% \n  ggplot(aes(xdist = .dist_obj, y = format(.dist_obj))) +\n  stat_dist_halfeye() +\n  facet_wrap(~nlpar, scales = \"free\") +\n  ggtitle(\"Scaled asymptotic length priors\") +\n  xlab(\"Value\") + ylab(\"Density\") +\n  theme_bw(12) +\n  theme(axis.text.y = element_text(angle = 90)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nTo get a better sense of what these prior imply, we can simulate the distribution of individual differences in $l_{inf}$ \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinf_sim = data.frame(offsets = rnorm(n_id*100, 0, .2)) %>% \n  mutate(linf_mu = rnorm(n(), (1 + offsets), sigma))\n  \nlinf_sim %>% \n  ggplot(aes(x = linf_mu)) +\n  stat_halfeye() +\n  xlim(-2,3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\nWe now fit the model to the simulated data\n\n\n::: {.cell}\n\n:::\n\n\n### Model inspection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(mods_list$gomp.to, effects = \"all\") %>%\n  kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|Parameter                               |Effects |Component   | Median|   CI| CI_low| CI_high|   pd| Rhat|     ESS|Group |\n|:---------------------------------------|:-------|:-----------|------:|----:|------:|-------:|----:|----:|-------:|:-----|\n|b_l0_Intercept                          |fixed   |conditional |   0.13| 0.95|   0.12|    0.14| 1.00|    1| 2221.01|      |\n|b_linf_Intercept                        |fixed   |conditional |   1.00| 0.95|   0.97|    1.04| 1.00|    1| 1853.79|      |\n|b_alpha_Intercept                       |fixed   |conditional |   0.03| 0.95|   0.03|    0.03| 1.00|    1| 1865.96|      |\n|sd_ID__l0_Intercept                     |random  |conditional |   0.01| 0.95|   0.01|    0.02| 1.00|    1| 2073.78|ID    |\n|sd_ID__linf_Intercept                   |random  |conditional |   0.12| 0.95|   0.09|    0.15| 1.00|    1| 1506.85|ID    |\n|sd_ID__alpha_Intercept                  |random  |conditional |   0.00| 0.95|   0.00|    0.00| 1.00|    1| 1640.96|ID    |\n|cor_ID__l0_Intercept__linf_Intercept    |random  |conditional |  -0.33| 0.95|  -0.62|    0.02| 0.97|    1| 1003.81|ID    |\n|cor_ID__l0_Intercept__alpha_Intercept   |random  |conditional |   0.07| 0.95|  -0.30|    0.43| 0.64|    1| 1036.33|ID    |\n|cor_ID__linf_Intercept__alpha_Intercept |random  |conditional |  -0.72| 0.95|  -0.86|   -0.46| 1.00|    1| 3286.74|ID    |\n|sigma                                   |fixed   |sigma       |   0.01| 0.95|   0.01|    0.01| 1.00|    1| 1478.80|      |\n\n\n:::\n\n```{.r .cell-code}\nplot(conditional_effects(mods_list$gomp.to, \n                         ndraws = 100, spaghetti = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n\n```{.r .cell-code}\npp_check(mods_list$gomp.to, ndraws = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-2.png){width=672}\n:::\n\n```{.r .cell-code}\nre = crossing(t = seq(min(df$t), \n                       max(df$t),\n                       length.out=100),\n               ID = unique(df$ID)) %>% \n  add_epred_draws(mods_list$gomp.to, re_formula = NULL,\n                  scale = \"response\", ndraws = 20)\n\nre %>% \n  ggplot(aes(y = .epred, x = t)) +\n  geom_line(aes(y = .epred, x = t, group = .draw), size = .5, alpha = .5) +\n  geom_point(data = df, aes(y=l, x=t, color = ID)) +\n  facet_wrap(~ID, nrow = 6, ncol = 5) + \n  scale_color_viridis() +\n  ylab(\"Mass (mg)\") + \n  xlab(\"Time\") +\n  theme_bw(12) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-3.png){width=672}\n:::\n:::\n\n\nThis recovers the parameter values pretty well! Note that there is some moderate correlation between $l_0$ and $l_{inf}$ due to sampling even if the true value is 0. The model seems to overestimate slightly this value compared to the value found in the simulated data. Let's now plot these correlations according to the model estimates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nre = mods_list$gomp.to %>%\n  spread_draws(# Population values\n    b_l0_Intercept, b_linf_Intercept, b_alpha_Intercept, \n    # Individual offsets\n    r_ID__l0[ID,Intercept], r_ID__linf[ID,Intercept], r_ID__alpha[ID,Intercept],\n    # Individual variances\n    sd_ID__l0_Intercept, sd_ID__linf_Intercept, sd_ID__alpha_Intercept,\n    sigma) %>% \n  # Individual offsets converted onto the original length scale (in micrometers)\n  mutate(L0_i = (b_l0_Intercept + r_ID__l0) * Linf_mu,\n         Linf_i = (b_linf_Intercept + r_ID__linf) * Linf_mu,\n         alpha_i = b_alpha_Intercept + r_ID__alpha) %>% \n  # Population averge distribution\n  mutate(L0_dist = rnorm(n(), b_l0_Intercept, sd_ID__l0_Intercept)*Linf_mu,\n         Linf_dist = rnorm(n(), b_linf_Intercept, sd_ID__linf_Intercept)*Linf_mu,\n         alpha_dist = rnorm(n(), b_alpha_Intercept, sd_ID__alpha_Intercept))\nre.mean = re %>% \n  select(.chain, .iteration, .draw, L0_i, Linf_i, alpha_i) %>% \n   mean_qi(L0_i, Linf_i, alpha_i)\n  # Summarize individual values into mean, lower and upper 95 % quantiles\n\n# Plot population average (diagonal elements)\nL0_dist = re %>% \n  ggplot(aes(x = L0_dist)) +\n  stat_histinterval(slab_color = \"gray45\", \n                    outline_bars = TRUE) +\n  labs(x = \"\", y = expression(L[0])) +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\nLinf_dist = re %>% \n  ggplot(aes(x = Linf_dist)) +\n  stat_histinterval(slab_color = \"gray45\", \n                    outline_bars = TRUE) +\n  labs(x = \"\", y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\nalpha_dist = re %>% \n  ggplot(aes(x = alpha_dist)) +\n  stat_histinterval(slab_color = \"gray45\", \n                    outline_bars = TRUE) +\n  labs(x = expression(alpha), y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\n\n# Plot individual average with CI (lower diagonal elements)\ncorr1 = re.mean %>% \n  ggplot(aes(x = L0_i, y = Linf_i)) +\n  geom_errorbarh(aes(xmin = L0_i.lower, xmax = L0_i.upper)) +\n  geom_errorbar(aes(ymin = Linf_i.lower, ymax = Linf_i.upper)) +\n  geom_point(alpha = .8, size = 3) +\n  labs(x = \"\", y = expression(L[inf])) +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\ncorr2 = re.mean %>% \n  ggplot(aes(x = L0_i, y = alpha_i)) +\n  geom_errorbarh(aes(xmin = L0_i.lower, xmax = L0_i.upper)) +\n  geom_errorbar(aes(ymin = alpha_i.lower, ymax = alpha_i.upper)) +\n  geom_point(alpha = .8, size = 3) +\n  labs(x = expression(L[0]), y = expression(alpha)) +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\ncorr3 = re.mean %>% \n  ggplot(aes(x = Linf_i, y = alpha_i)) +\n  geom_errorbarh(aes(xmin = Linf_i.lower, xmax = Linf_i.upper)) +\n  geom_errorbar(aes(ymin = alpha_i.lower, ymax = alpha_i.upper)) +\n  geom_point(alpha = .8, size = 3) +\n  labs(x = expression(L[inf]), y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\n\n# Plot correlation estimate (upper diagonal elements)\ndcorr1 = mods_list$gomp.to %>% \n  spread_draws(`cor.*`, regex = TRUE) %>% \n  ggplot(aes(x = cor_ID__l0_Intercept__linf_Intercept)) +\n  stat_halfeye() +\n  geom_vline(xintercept = 0, linewidth = 1, color = \"black\", linetype = \"dashed\") +\n  xlim(-1, 1) +\n  labs(x = \"\", y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\ndcorr2 = mods_list$gomp.to %>% \n  spread_draws(`cor.*`, regex = TRUE) %>% \n  ggplot(aes(x = cor_ID__l0_Intercept__alpha_Intercept)) +\n  stat_halfeye() +\n  geom_vline(xintercept = 0, linewidth = 1, color = \"black\", linetype = \"dashed\") +\n  xlim(-1, 1) +\n  labs(x = \"\", y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\ndcorr3 = mods_list$gomp.to %>% \n  spread_draws(`cor.*`, regex = TRUE) %>% \n  ggplot(aes(x = cor_ID__linf_Intercept__alpha_Intercept)) +\n  stat_halfeye() +\n  geom_vline(xintercept = 0, linewidth = 1, color = \"black\", linetype = \"dashed\") +\n  xlim(-1, 1) +\n  labs(x = \"\", y = \"\") +\n  theme_bw(12) +\n  theme(aspect.ratio=1)\n\n# Arrange plot into 3 x 3 grid\nL0_dist + dcorr1 + dcorr2 +\n  corr1 + Linf_dist + dcorr3 +\n  corr2 + corr3 + alpha_dist +\n  plot_layout(ncol = 3, nrow = 3, byrow = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=960}\n:::\n:::\n\n\nAnother possibility is to sample correlation estimates and plot those on a small grid with each color corresponding to the correlation strength. Solution found on [Matthew Kay](https://github.com/mjskay/uncertainty-examples/blob/master/multivariate-regression.md) and [Solomon Kurtz](https://bookdown.org/content/4857/adventures-in-covariance.html#summary-bonus-multilevel-growth-models-and-the-melsm) websites\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels = c(\"l[0]\", \"l[inf]\", \"alpha\")\n\nrho = as_draws_df(mods_list$gomp.to) %>% \n  select(starts_with(\"cor_\")) %>% \n  slice_sample(n = 60 * 60) %>% \n  bind_cols(crossing(x = 1:60, y = 1:60)) %>% \n  pivot_longer(cols = -c(x:y)) %>% \n  mutate(name = str_remove(name, \"cor_ID__\")) %>% \n  separate(name, into = c(\"col\", \"row\"), sep = \"__\") %>% \n  mutate(\n    col = case_when(\n      col == \"l0_Intercept\"   ~ \"l[0]\",\n      col == \"linf_Intercept\" ~ \"l[inf]\",\n      col == \"alpha_Intercept\" ~ \"alpha\"),\n    row = case_when(\n      row == \"l0_Intercept\"  ~ \"l[0]\",\n      row == \"linf_Intercept\" ~ \"l[inf]\",\n      row == \"alpha_Intercept\" ~ \"alpha\")) %>% \n  mutate(col = factor(col, levels = levels),\n         row = factor(row, levels = levels))\n\nrho %>% \n  full_join(rename(rho, col = row, row = col),\n            by = c(\"x\", \"y\", \"col\", \"row\", \"value\")) %>%\n  \n  ggplot(aes(x = x, y = y, fill = value)) +\n  geom_raster() +\n  scale_fill_distiller(type = \"div\", \n                       palette = \"RdBu\", \n                       limits = c(-1, 1), name = expression(rho)) +\n  # scale_fill_gradient2(expression(rho),\n  #                      low = \"#59708b\", mid = \"#FCF9F0\", high = \"#A65141\", midpoint = 0,\n  #                      labels = c(-1, \"\", 0, \"\", 1), limits = c(-1, 1)) +\n  scale_x_continuous(NULL, breaks = NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, breaks = NULL, expand = c(0, 0)) +\n  theme(strip.text = element_text(size = 12)) +\n  facet_grid(row ~ col, labeller = label_parsed, switch = \"y\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n## In conclusion\n\n\n## Mathematical description of the statistical models\n\nFormally, our statistical model can be described with the following set of equations\n\n### Non-scaled model\n\n$$\\begin{aligned}\n\n\\large \\text{Model Likelihood}\\\\ \n\\text{Average growth rate}\\\\\nL_{i,t} &\\sim N(\\mu_{i,t}, \\text{ } \\sigma)\\\\\n\n\\mu_{i,t} &= L_{inf_{i}}\\times e^{ln \\left( \\frac{L_{0_{i}}}{L_{inf_{i}}} \\right) \\times e^{-\\alpha_i t} } \\\\\n\n\\text{Among-individual covariance}\\\\\n\\begin{bmatrix}\n\\mu_{L_{0_{i}}}\\\\\n\\mu_{L_{inf_{i}}}\\\\\n\\mu_{\\alpha_i}\\\\\n\\end{bmatrix} &\\sim \n\nMVN(\\begin{bmatrix}\n\\mu_{L_{0}}\\\\\n\\mu_{L_{inf}}\\\\\n\\mu_{\\alpha}\\\\\n\\end{bmatrix}, \n\\Sigma)\\\\\n\n\\Sigma &=\n\\begin{bmatrix}\n\\sigma_{L_{0_{i}}} & 0 & 0\\\\\n0 & \\sigma_{L_{inf_{i}}} & 0 \\\\\n0 & 0 & \\sigma_{\\alpha_i}\n\\end{bmatrix} \n\nR \n\n\\begin{bmatrix}\n\\sigma_{L_{0_{i}}} & 0 & 0\\\\\n0 & \\sigma_{L_{inf_{i}}} & 0 \\\\\n0 & 0 & \\sigma_{\\alpha_i}\n\\end{bmatrix} \\\\\n\nR &= \n\\begin{bmatrix}\n1 & \\rho_{1,2} & \\rho_{1,3}\\\\\n\\rho_{1,2} & 1 & \\rho_{2,3} \\\\\n\\rho_{1,3} & \\rho_{2,3} & 1\n\\end{bmatrix} \\\\\n\n\\large \\text{Priors}\\\\\n\\text{Population Intercepts}\\\\\n\\mu_{L_{0}} &\\sim N(200, 40) \\\\\n\\mu_{L_{inf}} &\\sim N(1500, 300) \\\\\n\\mu_{\\alpha}  &\\sim N(0.03, 0.006) \\\\\n\n\\text{Among-individual variances}\\\\\n\\sigma_{L_{0_{i}}} &\\sim Exp(.025) \\\\\n\\sigma_{L_{inf_{i}}} &\\sim Exp(.003) \\\\\n\\sigma_{\\alpha_i} &\\sim Exp(170) \\\\\n\\sigma &\\sim Exp(1) \\\\\n\n\\text{Among-individual covariance}\\\\\nR &\\sim LKJ(2)\n\\end{aligned}$$\n\n### Scaled model\nCompared to the non-scaled model, the major difference here is that we put a strong prior around 1 for the $l_{inf}$ parameter.\n\n$$\\begin{aligned}\n\n\\large \\text{Model Likelihood}\\\\\n\\text{Average growth rate}\\\\\nl_{i,t} &\\sim N(\\mu_{i,t}, \\text{ } \\sigma)\\\\\n\n\\mu_{i,t} &= l_{inf_{i}}\\times e^{ln \\left( \\frac{l_{0_{i}}}{l_{inf_{i}}} \\right) \\times e^{-\\alpha_i t} } \\\\\n\n\\text{Among-individual covariance}\\\\\n\\begin{bmatrix}\n\\mu_{l_{0_{i}}}\\\\\n\\mu_{l_{inf_{i}}}\\\\\n\\mu_{\\alpha_i}\\\\\n\\end{bmatrix} &\\sim \n\nMVN(\\begin{bmatrix}\n\\mu_{l_{0}}\\\\\n\\mu_{l_{inf}}\\\\\n\\mu_{\\alpha}\\\\\n\\end{bmatrix}, \n\\Sigma)\\\\\n\n\\Sigma &=\n\\begin{bmatrix}\n\\sigma_{l_{0_{i}}} & 0 & 0\\\\\n0 & \\sigma_{l_{inf_{i}}} & 0 \\\\\n0 & 0 & \\sigma_{\\alpha_i}\n\\end{bmatrix} \n\nR \n\n\\begin{bmatrix}\n\\sigma_{L_{0_{i}}} & 0 & 0\\\\\n0 & \\sigma_{L_{inf_{i}}} & 0 \\\\\n0 & 0 & \\sigma_{\\alpha_i}\n\\end{bmatrix} \\\\\n\nR &= \n\\begin{bmatrix}\n1 & \\rho_{1,2} & \\rho_{1,3}\\\\\n\\rho_{1,2} & 1 & \\rho_{2,3} \\\\\n\\rho_{1,3} & \\rho_{2,3} & 1\n\\end{bmatrix} \\\\\n\n\\large \\text{Priors}\\\\\n\\text{Population Intercepts}\\\\\n\\mu_{L_{0}} &\\sim N(0.15, 0.03) \\\\\n\\mu_{L_{inf}} &\\sim N(1, 0.3) \\\\\n\\mu_{\\alpha}  &\\sim N(0.03, 0.006) \\\\\n\n\\text{Among-individual variances}\\\\\n\\sigma_{L_{0_{i}}} &\\sim Exp(34) \\\\\n\\sigma_{L_{inf_{i}}} &\\sim Exp(5) \\\\\n\\sigma_{\\alpha_i} &\\sim Exp(170) \\\\\n\\sigma &\\sim Exp(1) \\\\\n\n\\text{Among-individual covariance}\\\\\nR &\\sim LKJ(2)\n\\end{aligned}$$\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Paris\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] kableExtra_1.4.0       see_0.8.2              report_0.5.8          \n [4] parameters_0.21.5      performance_0.10.9     modelbased_0.8.7      \n [7] insight_0.19.8         effectsize_0.8.6       datawizard_0.9.1      \n[10] correlation_0.8.4      bayestestR_0.13.2      easystats_0.7.0       \n[13] viridis_0.6.5          viridisLite_0.4.2      marginaleffects_0.18.0\n[16] brms_2.20.12           Rcpp_1.0.12            tidybayes_3.0.6       \n[19] patchwork_1.2.0        lubridate_1.9.3        forcats_1.0.0         \n[22] stringr_1.5.1          dplyr_1.1.4            purrr_1.0.2           \n[25] readr_2.1.5            tidyr_1.3.1            tibble_3.2.1          \n[28] ggplot2_3.5.0          tidyverse_2.0.0       \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3   tensorA_0.36.2.1     rstudioapi_0.15.0   \n  [4] jsonlite_1.8.8       magrittr_2.0.3       farver_2.1.1        \n  [7] rmarkdown_2.25       ragg_1.2.7           vctrs_0.6.5         \n [10] base64enc_0.1-3      htmltools_0.5.7      distributional_0.4.0\n [13] curl_5.2.0           StanHeaders_2.32.5   htmlwidgets_1.6.4   \n [16] plyr_1.8.9           zoo_1.8-12           igraph_2.0.2        \n [19] mime_0.12            lifecycle_1.0.4      pkgconfig_2.0.3     \n [22] colourpicker_1.3.0   Matrix_1.6-5         R6_2.5.1            \n [25] fastmap_1.1.1        shiny_1.8.0          digest_0.6.34       \n [28] GGally_2.2.1         colorspace_2.1-0     ps_1.7.6            \n [31] textshaping_0.3.7    crosstalk_1.2.1      labeling_0.4.3      \n [34] fansi_1.0.6          timechange_0.3.0     abind_1.4-5         \n [37] compiler_4.3.2       withr_3.0.0          backports_1.4.1     \n [40] inline_0.3.19        shinystan_2.6.0      ggstats_0.5.1       \n [43] QuickJSR_1.1.3       pkgbuild_1.4.3       MASS_7.3-60.0.1     \n [46] gtools_3.9.5         loo_2.7.0            tools_4.3.2         \n [49] httpuv_1.6.14        threejs_0.3.3        glue_1.7.0          \n [52] nlme_3.1-164         promises_1.2.1       grid_4.3.2          \n [55] cmdstanr_0.7.1       checkmate_2.3.1      reshape2_1.4.4      \n [58] generics_0.1.3       gtable_0.3.4         tzdb_0.4.0          \n [61] data.table_1.15.0    hms_1.1.3            xml2_1.3.6          \n [64] utf8_1.2.4           pillar_1.9.0         ggdist_3.3.1        \n [67] markdown_1.12        posterior_1.5.0      later_1.3.2         \n [70] lattice_0.22-5       tidyselect_1.2.0     miniUI_0.1.1.1      \n [73] knitr_1.45           arrayhelpers_1.1-0   gridExtra_2.3       \n [76] V8_4.4.2             svglite_2.1.3        stats4_4.3.2        \n [79] xfun_0.42            bridgesampling_1.1-2 matrixStats_1.2.0   \n [82] DT_0.32              rstan_2.32.5         stringi_1.8.3       \n [85] yaml_2.3.8           evaluate_0.23        codetools_0.2-19    \n [88] cli_3.6.2            RcppParallel_5.1.7   shinythemes_1.2.0   \n [91] xtable_1.8-4         systemfonts_1.0.5    munsell_0.5.0       \n [94] processx_3.8.3       coda_0.19-4.1        svUnit_1.0.6        \n [97] parallel_4.3.2       rstantools_2.4.0     ellipsis_0.3.2      \n[100] dygraphs_1.1.1.6     bayesplot_1.11.1     Brobdingnag_1.2-9   \n[103] mvtnorm_1.2-4        scales_1.3.0         xts_0.13.2          \n[106] rlang_1.1.3          shinyjs_2.1.0       \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}